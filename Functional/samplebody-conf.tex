\section{Motivation}
During the history of computer science, object oriented programming has emerged as the most common programming paradigm to work with. There are good reasons, why OOP is used that frequent because the reusability and encapsulation. But everyone who had to implement mathematical functions into runnable code with this paradigm knows, that it has its difficulties. Another problem is concurrency and debbuging. If one ever had to check the state of a single variable in a larger code snippet line by line knows how much time and nerves this can take. Furhter complications arise, if one tries to delete elements out of a collection inside a loop and gets a concurrency error. Things like this can be time-consuming. Also parallel programming has its pitfalls because of the different states and modifications of Objects. And this is where one can see the benefits of functional programming. In this programming paradigm, amongst other things, variables are immutable and functions stateless. Additionally the usage of higher order functions(will be explained later) encourages parallel programming. Thanks to that, it is possible to transparently generate concurrency and one does not have to worry about variable changes.\\
\section{Functional Programming}
Functional Programming is a fundamentally  different way of thinking about how we want to apply the abstraction principle. Functional Programming is a Programming paradigm, were Functions not only can be defined and applied, but also linked together, set as parameters or as return values of functions.\\
A lot of well known programming languages own partial features of the functional programming paradigm. For instance in PHP or JavaScript, one can work with Higher order Functions(explained later). Nevertheless, neither PHP nor JavaScript are declared as functional programming languages. Because of that, one has to differentiate between pure functional programming languages and impure ones.\\
\begin{MyIndentedList}
    \begin{MyIndentedList}
        \item - Pure Functional Languages -> support only the functional paradigms
        \item - Impure Functional Languages -> support functional\\ paradigms and imperative style[1]
    \end{MyIndentedList}
\end{MyIndentedList}
\subsection{characteristics}
There are some typical characteristics in all pure functional programming languages:\\
\begin{MyIndentedList}
    \begin{MyIndentedList}
        \item - Functional Programming supports higher-order functions and lazy evaluation features.
        \item - Functional Programming don't support flow controls like Loop and conditional statements.
        \item - Functional Programming uses "Recursion" concept to iterate through collection data.
        \item - Functional Programming supports popular concepts, such as Abstraction, Encapsulation, Inheritance and Polymorphism.
        \item - Variables in functional Programming are always final.
    \end{MyIndentedList}
\end{MyIndentedList}\\
Most of these characteristics are self explaining . However, higher order functions and lazy evaluation are not common knowledge and need further explanation.
\subsubsection{Higher order functions(HoF)}
A Higher Order Function is a function that has at least one of the following conditions:\\
- Takes one or more functions as argument\\
- return a function as its result\\\\\\\\\\
An example of higher order function in PHP:\\\\
>><?php\\
>> \$funct1 = function(\$funcParam, \$param)\{\\
>>  \tab return \$funcparam(\$param);\\
>>\};\\
>>\\
>>\$funct2 = function(\$param)\{\\
>>\tab return 2 + \$param;\\
>>\};\\
>>\\
>> echo(\$funct1(\$funct2,3));\\
>> ?>\\\\
But what are the benefits of this, one might ask. A simple example will help:\\
Just imagine an array in Java with five integer elements in it. Now one wants to square all elements inside. With Java this is easily made by iterating through the array with a for loop. In functional programming, one can not use for loops like in the Object oriented paradigm. So in this case to get the same result, one has to work with a so called .map() function. Thanks to the capability of HoF in functional programming, one can give functions other functions as parameters. lets compare the two implementations with pseudo code:\\
implementation in Object oriented Paradigm:\\\\
>>list = [1,2,3,4,5];\\
>>for(list.length)\{\\
>> \tab list[currentElem] = currentElem * currentElem;\\
\}\\\\
implementation in functional paradigm:\\\\
>>list = [1,2,3,4,5];\\
>>list2 = list.map((num) -> num * num);\\\\
One might ask why the effort to create a new list instead of simply modifying the old one (variables/values are always final in functional programming). Imagine now again a list with integer values. But instead of five elements, there are ten million elements in it. The for loop will iterate trough all ten million elements sequentially. But the functional approach can easily run these calls parallel, which will make its performance better compared to the for loop solution.[2]
\subsubsection{Lazy Evaluation}
In plain functional programming languages, expressions are not evaluated strictly by principle. An expression will only be replaced, if the expression is needed. Consequently, also given parameters of a function will only be evaluated, if the expression is needed inside the function body.\\ 
A simple Example clarifies this strategy.\\\\
>> const1 param = 1\\\\
Defines a constant function "const1" wit a parameter "param" and a return value "1". Following from this, the return value will always be 1.\\\\
(Pseudocode)\\
>> const1 10 => 1\\
>> const1 (1+4) => 1\\
>> const1 'A' => 1\\
>> const1 (1/0) => 1\\\\
Since the parameter is not relevant for the return value of the function, the interpreter will not evaluate it. Due to this, the last call with a division of zero will not throw an error.[3]
\subsection{Implementation}
In scope of the informatics seminar, we received the task to implement some algorithm of our choice in both paradigms in order to compare the differences and similarities between them. We had to decide between the Dijkstra algorithm and the knapsack algorithm. After evaluating the complexity of both, we decided to take the second one. The knapsack algorithm has been implemented twice. One implementation in java, based on the object oriented programming paradigm and one implementation on Erlang, based on the functional programming paradigm.
\subsubsection{The Knapsack algorithm}
In order to understand how the implementation works, one has to understand the knapsack algorithm at first.\\
The Knapsack problem is a problem in combinatorial optimization.\footnote{topic, that consists of finding an optimal object from a finite set of objects}\\
Imagine a knapsack with a maximum weight w=15kg. There is a set of different items. Each one with a different weight and a different value. One can only put items inside the knapsack as long as the the maximum weight of 15kg is not exceeded. The goal is to gain as much value v inside the knapsack. Or in other words:\\
Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack.\\\\\\\\\\\\
\textbf{Mathematical explanation:}\\
N := Number of Items\\
$v_i$ := value of the i-th item\\
$x_i$ := the i-th item\\
$w_i$ := weight of the i-th item\\
W := maximum weight\\\\
\textbf{maximize} $\sum\limits_{i=1}^n v_i * x_i$ \tab \textbf{subject to} \tab $\sum\limits_{i=1}^n w_i * x_i \leq W$\\\\
(where $x_i$ either can be 0 for not included or 1 for included)\\\\
For the implementation, we have to define sub-problems: We have \textbf{N} items so we have to make \textbf{N} decisions whether to take the item with given index or not.\\\\
The \underline{sub-problems}: The solution considering every possible combination of remaining items and remaining weight.\\\\
S[i][w] = the solution to the sub-problem corresponding the first i items and available weight w.\\\\
For the value S[i][w], one has basically two options:\\\\
\tab \textbf{S[i][w] = Math.max( S[i-1][w] ; $v_i$ + [i-1][w-$w_i$] )}\\\\
(but we will only consider $v_i$ + [i-1][w-$w_i$] if it can fit w \leq $w_i$)\\\\
A simple example will clarify this strategy:\\\\
Imagine having a knapsack with a maximum weight of \textbf{W = 5kg} and \textbf{N = 3} items. \\\\ 
\begin{tabular}{l l l}
Item #1         & $w_1$ = 4kg & $v_1$ = 10\textdollar                  \\\hline
Item #2         & $w_2$ = 2kg & $v_2$ = 4\textdollar                   \\\hline
Item #3         & $w_3$ = 3kg & $v_3$ = 7\textdollar                   \\\hline
\end{tabular}\\\\\\
Now, we draw a two dimensional array where a row represents all possible combinations of items and a column represents one kilogram:\\\\
\begin{tabular}{l|l|l|l|l|l|l|l|l}
                &   & 0 & 1 & 2 & 3 & 4 & 5 & weights{[}kg{]} \\ \hline
No items        & 0 &   &   &   &   &   &   &                 \\
First item      & 1 &   &   &   &   &   &   &                 \\
First two items & 2 &   &   &   &   &   &   &                 \\
All items       & 3 &   &   &   &   &   &   &                
\end{tabular}\\\\\\
In a first step we can fill the first column and the first row with zeros, since zero items will automatically weights zero kilograms and none of the items weights zero kilograms.\\\\
\begin{tabular}{l|l|l|l|l|l|l|l|l}
                &   & 0 & 1 & 2 & 3 & 4 & 5 & weights{[}kg{]} \\ \hline
No items        & 0 & \textcolor{green}{0}  & \textcolor{green}{0}  & \textcolor{green}{0}  & \textcolor{green}{0}  & \textcolor{green}{0}  & \textcolor{green}{0}  &                 \\
First item      & 1 & \textcolor{green}{0}  &   &   &   &   &   &                 \\
First two items & 2 & \textcolor{green}{0}  &   &   &   &   &   &                 \\
All items       & 3 & \textcolor{green}{0}  &   &   &   &   &   &                
\end{tabular}\\\\\\
From now on, one has just to use the formula \\\\ \textbf{S[i][w] = Math.max( S[i-1][w] ; $v_i$ + [i-1][w-$w_i$] )} \\\\
for each field in the array in order to get the desired results.\\
The final table will look like this:\\\\
\begin{tabular}{l|l|l|l|l|l|l|l|l}
                &   & 0 & 1 & 2 & 3 & 4 & 5 & weights{[}kg{]} \\ \hline
No items        & 0 & \textcolor{green}{0}  & \textcolor{green}{0}  & \textcolor{green}{0}  & \textcolor{green}{0}  & \textcolor{green}{0}  & \textcolor{green}{0}  &                 \\
First item      & 1 & \textcolor{green}{0}  & \textcolor{green}{0}  & \textcolor{green}{0}  & \textcolor{green}{0}  & \textcolor{green}{10}  & \textcolor{green}{10}  &                 \\
First two items & 2 & \textcolor{green}{0}  & \textcolor{green}{0}   & \textcolor{green}{4}  & \textcolor{green}{4} & \textcolor{green}{10}  & \textcolor{green}{10}  &                 \\
All items       & 3 & \textcolor{green}{0}  & \textcolor{green}{0}   & \textcolor{green}{4}  & \textcolor{green}{7} & \textcolor{green}{10}  & \textcolor{green}{11}  &                
\end{tabular}\\\\\\
The solution is the value in the last row and last column. The next question is, which of the available items have been taken.\\
In order to find the taken elements, one compares the value in the last row and last column with the value above it(10). If this item is not equal to the last element, one can conclude that the last item is included in the knapsack. In this case, the last(third) item has a weight of 3kg. Because of that, one has to go to the row above and move three steps/3kg to the left. Repeat these steps until no more weight is available.\\
Or in other words[4]:\\\\
(Pseudocode)\\
>> for(n = numOfItems, w = capacityOfKnapsack ; n>0 ; n--)\{\\
>>\tab if(S[n][w] != 0 && S[n][w] != S[n-1][w]\{\\
>>\tab \tab print S[n][w] + "is taken";\\
>>\tab \tab w = w - S[n][w].weight\};\\
>>\tab \}\\\\
\begin{tabular}{l|l|l|l|l|l|l|l|l}
                &   & 0 & 1 & 2 & 3 & 4 & 5 & weights{[}kg{]} \\ \hline
No items        & 0 & 0 & 0 & 0  & 0  & 0  & 0  &                 \\
First item      & 1 & \textcolor{red}{0}  & 0 & 0 & 0 & 10 & 10 &   \\
First two items & 2 & 0 & 0 & \textcolor{red}{4} & 4 & 10 & 10 &  \\
All items       & 3 & 0 & 0 & 4 & 7 & 10 & \textcolor{red}{11}  &                
\end{tabular}\\\\
\subsubsection{implementation in Java}
The implementation of the Knapsack algorithm in the Object Oriented language Java appear straightforward, due to the fact that students at the University of Applied Science Bern learn how to code Java from the very beginning. Once the algorithm is understood in theory, the actual implementation is simple to reconstruct.\\ 
There are a lot of possible implementations for the knapsack problem. We chose the dynamic programming\footnote{In computer sciene, dynamic programming is method for solving complex problems by breaking them down into a set of simpler problems and solve them first.} approach, in order to solve the problem.\\\\
\textbf{Java Code}\\
\includegraphics[scale= 0.6]{knapsack_java_class}\\
The body of the Knapsack Class.\\\\
\includegraphics[scale = 0.6]{knapsack_java_constructor}\\
The constructor of the Knapsack class.\\\\
\includegraphics[scale = 0.6]{knapsack_java_solve}\\
The actual solving method for the knapsack algorithm with dynamic programming approach.\\\\
\includegraphics[scale = 0.6]{knapsack_java_printRes}\\
Method for printing calculated methods.\\\\
\includegraphics[scale = 0.6]{knapsack_java_main}\\
Usage of the Knapsack class.\\\\

\textbf{Run-time complexity}\\
The run-time complexity of this Java implementation with the dynamic programming approach is :\\\\
\tab \tab \tab \tab \textbf{$O(n*W)$}\\\\
where:\\
$n = $ number of items\\
$W = $ maximum weight of knapsack
\subsubsection{implementation in Erlang}
The implementation of the knapsack algorithm in Erlang is more complex. If one has no prior knowledge of functional programming nor the Erlang programming language, it will take some time to understand this implementation. before looking at the code, it is important to know some very basic Erlang syntax. In the list below, one can find the necessary key values in order to understand our implementation.\\\\
\begin{tabular}{|lp{5cm}|}
\hline
-define(name, value)  & Since variables are always final in pure functional programming languages, one has to define them like this.\\ \hline
[H|T] & A non empty list pattern matches with [Head|Tail], where Head is the very first element in the list and Tail the remainder of the list. \\  \hline
\?variableName & creates a pointer to the desired variable. \\ \hline
\_variableName & The compiler normally warns you about a variable which is bound in a pattern but is never used, often a sign of an error. But the compiler does not warn for variables prefixed with \_ like in \_Var. The intent being that I want to give the variable a name, naming things is good, but that I know I will never use it.[5] \\ \hline 
. & A point is the equivalent to a semicolon in Java.\\ \hline
\end{tabular}\\
\pagebreak
\textbf{Erlang Code}\\
\includegraphics[scale= 0.8]{knapsack_erlang1}\\
\includegraphics[scale= 0.8]{knapsack_erlang2}\\
Code from whole Erlang Program with necessary Comments\\
\textbf{run-time complexity}\\
Insert text here.\\
Inser text here.\\

\subsubsection{Comparison}
\textbf{Object Oriented}\\
First of all, a class has been created. Inside the constructor we give the object all necessary information in order to solve the knapsack problem, plus a two dimensional int array (with given size) is created.Inside the "solve()" method, we iterate with two "for-loops" through this array and just fill the values like explained in the knapsack theory part. Inside the "printRes()" method, we iterate again trough the list with one "for-loop" and worked additionally with an "if-statement" in order to pick the right items.\\
As one can see, iteration is the key in this solution.\\
\textbf{Functional}\\
In order to understand where the program starts, it is important to know that the Erlang language does not have something like a main method in Java to set an entry point. Instead one can choose any method as an entry point. It is sufficient to tell Erlang where to start in order to run the program. Instead of working with for loops, we had to use recursion instead. As one can see, there is also polymorphism implemented for the calculate solution depending on the given parameters.\\
As one can see, recursion is the key in this solution.

\subsection{Citations}
[1] Ted Neward 2016, why Functional Programming Matters https://www.youtube.com/watch?v=oB8jN68KGcU&t=531s\\
[2] Marijn Haverbeke 2015, eloquent JavaScript https://eloquent javascript.net/05\_higher\_order.html\\
[3] Arne Steinmetz 2002, Vor- und Nachteile gegenueber Parameteruebergabe per Wert und per Referenz http://www.fh-wedel.de/~si/seminare/ss02/Ausarbeitung/3.lazy/lazy0.htm\\
[4] Balazs Holczer 2017, Knapsack Problem - Introduction https ://www.youtube.com/watch?v=srT9IYCYxyc\\
[5] https://stackoverflow.com/questions/13707361/anonymous-variables-in-erlang \\


\section{Conclusions}
